= http-client

== uml

=== startup

[plantuml, "http-client-init-seq.puml", svg]
----
hide footbox

participant "**main()**\n\n" as main
participant "**folly::Init**\n\n" as Init
participant "**EventBase**\n\n" as EventBase
participant "**WheelTimerInstance**\n\n" as WheelTimerInstance
participant "**std::thread**\n\n" as thread
participant "**Test**\n\n" as Test

main -> Init : ctor{ &argc, &argv }
main -> EventBase : eb=ctor{}

main -> WheelTimerInstance : timer=ctor{ defaultTimeout, eb }
note right #ff8888
    must create before starting event loop
   
    Event handlers with timeout callbacks are registered with the timer.
    If an event occurs before a timeout then the timeout callback is removed.
    No race condition is possible since timeout events and all other events
    are serviced from the same thread.
end note 

main -> thread : ctor{ run_event_loop( &eb ) }
main -> Test : test=ctor{}

main -> Test : run()
note left #ff0000: todo

main -> thread : join()
----




=== original

[plantuml, "http-client-original-seq.puml", svg]
----
hide footbox

participant "**EventBase**\n\n" as EventBase
participant "**Test**\n\n" as Test
participant "**HttpClient**\n\n" as HttpClient
participant "**Future**\n\n" as Future
participant "**HttpConnector**\n\n" as HttpConnector
participant "**SocketAddress**\n\n" as SocketAddress
participant "**HTTPUpstreamSession**\n\n" as HTTPUpstreamSession

-> Test : run()
Test -> HttpClient : ctor{ EventBase, timer, url, headers }

HttpClient -> HttpConnector : ctor{ this, timer }

Test -> HttpClient : POST( "nacho" )

HttpClient -> SocketAddress : addr=ctor{ Host, Port, allowNameLookup=true }
HttpClient -> HttpConnector : connect( EventBase, addr, ... )

group connect success
    EventBase -> HttpClient : connectSuccess( HTTPUpstreamSession )
    HttpClient -> HTTPUpstreamSession : setFlowControl( 65536, 65536, 65536 )
    note left: set receive buffer sizes, strange name?
    
    HttpClient -> TransactionHandler : txnHandler=ctor{ this }
    
    HttpClient -> HTTPUpstreamSession : txn=newTransaction( txnHandler )
    'HTTPUpstreamSession -> HTTPUpstreamSession : newTransactionWithError( txnHandler )
    'HTTPUpstreamSession -> HTTPUpstreamSession : startNow()
    'HTTPUpstreamSession -> HTTPSession : startNow()    
    'HTTPUpstreamSession -> HTTPSession : createTransaction()
    
    HttpClient -> HttpClient : setupHeaders()
    note left: create HTTPMessage 
    
    HttpClient -> HTTPTransaction : sendHeaders( HTTPMessage )
    HttpClient -> HTTPTransaction : sendEOM()
    
end group

HttpClient --> Test : Future
Test -> Future : thenValue( HttpResponseHandler )

== post ==
 
----

=== how should it work?



[source, c++]
----
void Test::run() {
    httpClient.connect( address )
              .thenValue([]() {
                  return run_tests();
              })
              .thenError([]() {
                  // How to distinguish fail vs. error?
              });
}
----


[plantuml, "state.puml", svg]
----
[*] --> Setup
Setup --> TestStep
Setup --> Error
TestStep --> Error
TestStep --> Fail
TestStep --> Pass

'State1 : this is another string

Pass --> Setup
Pass --> [*]
Fail --> [*]
Error --> [*]

----



== http client connect

// github
ifeval::["{docdir}" == ""]
image::http-client-connect_puml.png[]
endif::[]


// eclipse asciidoc plugin
ifeval::["{docdir}" != ""]

[plantuml, "http-client-connect.puml", svg]
----
hide footbox

participant "**EventBase**" as EventBase
participant "**Test.cpp**" as test_cpp
participant "**HttpClient**" as HttpClient
participant "**HttpConnector**" as HttpConnector
participant "**Future**" as Future
participant "**SocketAddress**" as SocketAddress
participant "**SocketOptionMap**" as SocketOptionMap

'participant "**URL**" as URL

group callback
    EventBase -> test_cpp : callback()
    
    group HttpClient ctor
        test_cpp -> HttpClient : ctor{ EventBase, url, headers }
        HttpClient -> HttpConnector : ctor{ this, timer }        
    end group

    group HttpClient.POST()
        test_cpp -> HttpClient : POST("nacho")
        HttpClient -> SocketAddress : addr=ctor{}
        
        HttpClient -> SocketOptionMap : options=ctor{}
        note left: static initialization
        
        HttpClient -> HttpConnector : connect( eb_, socketAddress, timeout, options )
    end group
    
    HttpClient --> test_cpp : future
    test_cpp -> Future : thenValue( response_handler(HttpResponse&&) )
    test_cpp --> EventBase : future
end group

'main -> HttpClient : ctor{ eb, HTTPMethod::GET, proxy=nullptr, headers, input_filename, h2c=true )
'main -> SocketAddress : addr=ctor{ host, port, allowNameLookup=true }
----

endif::[]


== http get detail


// for github
ifeval::["{docdir}" == ""]
image::http-get_puml.png[]
endif::[]


// for eclipse asciidoc plugin
ifeval::["{docdir}" != ""]


[plantuml, "http-get.puml", svg]
----

participant "**main()**" as main
participant "**HttpClient**" as HttpClient
participant "**EventBase**" as EventBase
participant "**AsyncSocket**" as AsyncSocket
participant "**HTTPConnector**" as HTTPConnector
participant "**HTTPUpstreamSession**" as HTTPUpstreamSession
participant "**HTTPTransaction**" as HTTPTransaction


main -> HTTPConnector : connector=ctor{ &HttpClient, WheelTimer{ request_timeout, &eb } }
main -> HTTPConnector : connect( &eb, addr, connect_timeout, socket_options )
main -> EventBase : loop()
note right
  This is the event loop. All events are run in this thread
end note

HTTPConnector -> AsyncSocket : sock=ctor{ eventBase }
HTTPConnector -> HttpClient : preConnect( sock )
HTTPConnector -> AsyncSocket : connect(this, ... )
AsyncSocket -> HTTPConnector : preConnect( NetworkSocket )

== sends request on connect success event ==

AsyncSocket -> HTTPConnector : connectSuccess()
HTTPConnector -> HttpClient : connectSuccess( HTTPUpstreamSession session )

HttpClient -> HTTPUpstreamSession : setFlowControl( **...** )
HttpClient -> HTTPUpstreamSession : txn=newTransaction( this )
HttpClient <- HttpClient : sendRequest( txn )

group send request
    HttpClient -> HttpClient : setupHeaders()
    HttpClient -> HTTPTransaction : sendHeaders( /*proxygen::HTTPMessage*/ request_ )
    HttpClient -> HTTPTransaction : sendEOM() // end of message
end group

HttpClient -> HTTPUpstreamSession : closeWhenIdle()

== response events ==

HTTPTransaction -> HttpClient : onHeadersComplete( unique_ptr<proxygen::HTTPMessage> )

HTTPTransaction -> HttpClient : onBody( unique_ptr<folly::IOBuf> )
note left
    called repeatedly until
    message is complete
end note

HTTPTransaction -> HttpClient : onEOM()
note across
    **NOTE:** HttpClient::onError() can be called between HttpClient::onEOM() and HttpClient::detachTransaction()
end note

HTTPTransaction -> HttpClient : detachTransaction()
----

endif::[]



=== class diagram

[plantuml, "classes.puml", svg]
----
class "**HttpClient**\n\n" as HttpClient

class "**HTTPSession**\n\nHTTPSession.h" as HTTPSession
note left
    This implements a LOT of
    callback handler interfaces
end note

class "**HTTPUpstreamSession**\n\nHTTPUpstreamSession.h" as HTTPUpstreamSession
class "**HTTPTransaction**\n\nHTTPTransaction.h" as HTTPTransaction


HTTPSession <- HTTPUpstreamSession

class HttpClient {
    - Promise connected_
    
    + Promise **connect**( host, port )
    + Future<HttpResponse> **GET**( path )
    + Future<HttpResponse> **POST**( path, content )
}

class HTTPSession {
    {abstract} **setFlowControl**(\n  size_t initialReceiveWindow,\n  size_t receiveStreamWindowSize,\n  size_t receiveSessionWindowSize )
}


class HTTPTransaction {
    +{abstract} sendHeaders( HTTPMessage )
    +{abstract} sendHeadersWithEOM( HTTPMessage )
}


class HTTPMessage {
    folly::Optional<HTTPMethod> getMethod()
    
    string getProtocolString()
    string getMethodString()
    string getPath()
    string getQueryString()
    string getURL()

    getHeaders()
}

----


