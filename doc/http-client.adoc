= http-client

== how should it work?


[source, c++]
----
void main() {
    // ...
    eventBase.runInEventBaseThread([&]() {
    
        httpClient.connect( host, port, /*isSecure=*/false )
                  .thenValue([&]( Unit ) {
                      return httpClient.POST("/some/path", "content");
                  })
                  .thenValue([]( HttpResponse response ) {
                      // ...
                  })
                  .thenError([](const std::exception& e) {
                      // ...
                  });
    });
              
    eventBase.loop()
}
----


== uml


=== create

[plantuml, "http-client-init-seq.puml", svg]
----
hide footbox

participant "**main()**\n\n" as main
participant "**folly::Init**\n\n" as Init
participant "**EventBase**\n\n" as EventBase
participant "**HttpClient**\n\n" as HttpClient
participant "**WheelTimerInstance**\n\n" as WheelTimerInstance
participant "**HTTPConnector**\n\n" as HTTPConnector


main -> Init : ctor{ &argc, &argv }
main -> EventBase : eb=ctor{}

main -> HttpClient : ctor{ EventBase, defaultTimeout, url, headers }

HttpClient -> WheelTimerInstance : timer=ctor{ defaultTimeout, EventBase }
note right #ff8888
    must create before starting event loop or in the event loop thread
   
    Event handlers with timeout callbacks are registered with the timer.
    If an event occurs before a timeout then the timeout callback is removed.
    No race condition is possible since timeout events and all other events
    are serviced from the same thread.
end note

HttpClient -> HTTPConnector : ctor{ this, timer }        

----


=== connect

[plantuml, "http-client-connect-seq.puml", svg]
----
hide footbox

participant "**AsyncSocket**\n\n" as AsyncSocket
participant "**HttpClient**\n\n" as HttpClient
participant "**Promise**\n\n" as Promise
participant "**HTTPConnector**\n\n" as HTTPConnector
participant "**SocketAddress**\n\n" as SocketAddress
participant "**HTTPUpstreamSession**\n\n" as HTTPUpstreamSession



-> HttpClient : connect()

HttpClient -> SocketAddress : addr=ctor{ Host, Port, allowNameLookup=true }
HttpClient -> HTTPConnector : connect( &eb, addr, connect_timeout, socket_options )
HttpClient -> Promise : getFuture()
<-- HttpClient : Future

HTTPConnector -> AsyncSocket : sock=ctor{ eventBase }
HTTPConnector -> HttpClient : preConnect( sock )
HTTPConnector -> AsyncSocket : connect(this, ... )
AsyncSocket -> HTTPConnector : preConnect( NetworkSocket )

== connect success ==

AsyncSocket -> HTTPConnector : connectSuccess()
HTTPConnector -> HttpClient : connectSuccess( HTTPUpstreamSession session )

HttpClient -> HTTPUpstreamSession : setFlowControl( **...** )
note left: set receive buffer sizes

HttpClient -> Promise : setValue()

== connect error ==

AsyncSocket -> HTTPConnector : connectErr( AsyncSocketException )
HTTPConnector -> HttpClient : connectError( AsyncSocketException )
HttpClient -> Promise : setException( AsyncSocketException ) 
----

== POST


// for github
ifeval::["{docdir}" == ""]
image::http-get_puml.png[]
endif::[]


// for eclipse asciidoc plugin
ifeval::["{docdir}" != ""]


[plantuml, "http-client-get.puml", svg]
----

participant "**HttpClient**" as HttpClient
participant "**AsyncSocket**" as AsyncSocket
participant "**TransactionHandler**" as TransactionHandler
participant "**HTTPConnector**" as HTTPConnector
participant "**HTTPUpstreamSession**" as HTTPUpstreamSession
participant "**HTTPTransaction**" as HTTPTransaction


-> HttpClient : POST( "content" )
HttpClient -> HTTPUpstreamSession : txn=newTransaction( this )
HTTPUpstreamSession -> HTTPUpstreamSession : newTransactionWithError( txnHandler )
HTTPUpstreamSession -> HTTPUpstreamSession : startNow()
HTTPUpstreamSession -> HTTPUpstreamSession : HTTPSession::startNow()    
HTTPUpstreamSession -> HTTPUpstreamSession : HTTPSession::createTransaction()
HTTPUpstreamSession --> HttpClient : HTTPTransaction

HttpClient <- HttpClient : sendRequest( txn )

group send request
    HttpClient -> HttpClient : request=createHttpMessage()
    HttpClient -> HTTPTransaction : sendHeaders( /*proxygen::HTTPMessage*/ request )
    HttpClient -> HTTPTransaction : sendBody( content )
    HttpClient -> HTTPTransaction : sendEOM() // end of message
end group

<- HttpClient : Future<HttpResponse>


== response events ==

HTTPTransaction -> TransactionHandler : onHeadersComplete( unique_ptr<proxygen::HTTPMessage> )

HTTPTransaction -> TransactionHandler : onBody( unique_ptr<folly::IOBuf> )
note left
    called repeatedly until
    message is complete
end note

HTTPTransaction -> TransactionHandler : onEOM()
note across
    **NOTE:** HttpClient::onError() can be called between HttpClient::onEOM() and HttpClient::detachTransaction()
end note

HTTPTransaction -> TransactionHandler : detachTransaction()
----

endif::[]


=== class diagram

[plantuml, "classes.puml", svg]
----
class "**HttpClient**\n\n" as HttpClient

class "**HTTPSession**\n\nHTTPSession.h" as HTTPSession
note left
    This implements a LOT of
    callback handler interfaces
end note

class "**HTTPUpstreamSession**\n\nHTTPUpstreamSession.h" as HTTPUpstreamSession
class "**HTTPTransaction**\n\nHTTPTransaction.h" as HTTPTransaction


HTTPSession <- HTTPUpstreamSession

class HttpClient {
    - Promise<Unit> connected_
    - Promise<HttpResponse> requestComplete_
    
    + Future<Unit> **connect**( host, port )
    + Future<HttpResponse> **GET**( path )
    + Future<HttpResponse> **POST**( path, content )
}

class HTTPSession {
    {abstract} **setFlowControl**(\n  size_t initialReceiveWindow,\n  size_t receiveStreamWindowSize,\n  size_t receiveSessionWindowSize )
}


class HTTPTransaction {
    +{abstract} sendHeaders( HTTPMessage )
    +{abstract} sendHeadersWithEOM( HTTPMessage )
}


class HTTPMessage {
    folly::Optional<HTTPMethod> getMethod()
    
    string getProtocolString()
    string getMethodString()
    string getPath()
    string getQueryString()
    string getURL()

    getHeaders()
}

----


