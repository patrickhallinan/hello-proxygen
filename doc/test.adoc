= test

ifeval::["{docdir}" == ""]
:imagesdir: image
endif::[]



== init

// github
ifeval::["{docdir}" == ""]
image::curl-init_puml.png[]
endif::[]


// eclipse asciidoc plugin
ifeval::["{docdir}" != ""]

[plantuml, "curl-init.puml", svg]
----
hide footbox

participant "**main()**" as main
participant "**folly::Init**" as Init
participant "**Test**" as test
participant "**EventBase**" as EventBase
participant "**HttpClient**" as HttpClient
participant "**HTTPConnector**" as HTTPConnector


main -> Init : ctor{ &argc, &argv }
main -> EventBase : eb=ctor{}

main -> test : ctor{ eb, timer }

test -> HttpClient : ctor{\n  EventBase,\n  defaultTimeout,\n  url,\n  headers }

HttpClient -> HTTPConnector : ctor{ this, timer }        

main -> test : run()

test -> EventBase : runInEventBaseThread( callback )

main -> EventBase : loop()
----

endif::[]


== test ==

[plantuml, "test.puml", svg]
----
hide footbox

participant "**EventBase**" as EventBase
participant "**HttpClient**" as HttpClient
participant "**Promise**" as Promise
participant "**Test**" as test
participant "**TransactionHandler**" as TransactionHandler
participant "**HTTPUpstreamSession**" as HTTPUpstreamSession
participant "**HTTPTransaction**" as HTTPTransaction
participant "**HTTPConnector**" as HTTPConnector


EventBase -> test : callback()
test -> HttpClient : connect()

HttpClient -> HTTPConnector : connect( EventBase, socketAddress, timeout, SocketOptionMap )
HttpClient -> Promise : ctor{}
HttpClient -> Promise : getFuture()
HttpClient --> test : Future

== connect success ==

HTTPConnector -> HttpClient : connectSuccess( HTTPUpstreamSession )
HttpClient -> Promise : setValue()

== .thenValue() ==

EventBase -> test : callback()
test -> HttpClient : GET()
HttpClient -> TransactionHandler : txnHandler=ctor{ this }
HttpClient -> HTTPUpstreamSession : newTransaction( txnHandler )
HttpClient -> HttpClient : http_message=createHttpMessage( GET )
HttpClient -> HTTPTransaction : sendHeaders( http_message )
HttpClient -> HTTPTransaction : sendEOM()

HttpClient --> test : Future

== GET response ==

HTTPTransaction -> TransactionHandler : 

HTTPTransaction -> TransactionHandler : onHeadersComplete( unique_ptr<proxygen::HTTPMessage> )

HTTPTransaction -> TransactionHandler : onBody( unique_ptr<folly::IOBuf> )
note left
    called repeatedly until
    message is complete
end note

HTTPTransaction -> TransactionHandler : onEOM()
note across
    **NOTE:** TransactionHandler::onError() can be called between TransactionHandler::onEOM() and TransactionHandler::detachTransaction()
end note

TransactionHandler -> HttpClient : requestComplete( httpResponse )
HttpClient -> Promise : setValue( httpResponse )

HTTPTransaction -> TransactionHandler : detachTransaction()

== .thenValue() ==

EventBase -> test : callback( HttpResponse )

test -> HttpClient : POST( "Echo" )
HttpClient -> TransactionHandler : txnHandler=ctor{ this }
HttpClient -> HTTPUpstreamSession : newTransaction( txnHandler )
HttpClient -> HttpClient : http_message=createHttpMessage( GET )
HttpClient -> HTTPTransaction : sendHeaders( http_message )
HttpClient -> HTTPTransaction : sendBody( content )
HttpClient -> HTTPTransaction : sendEOM()

HttpClient --> test : Future

== etc... ==
----


== classes

// for github
ifeval::["{docdir}" == ""]
image::classes_puml.png[]
endif::[]


// for eclipse asciidoc plugin
ifeval::["{docdir}" != ""]


[plantuml, "classes.puml", svg]
----



class "**AsyncSocket**" as AsyncSocket

class "**AsyncSocketTransport**\n\nfolly/io/async/AsyncSocketTransport.h" as AsyncSocketTransport

abstract "**ConnectCallback**\n\nfolly/io/async/AsyncSocketTransport.h*" as ConnectCallback

class "**EventBase**" as EventBase
class "**HTTPConnector**\n\nhttp/HTTPConnector.h" as HTTPConnector
class "**Callback**\n\nhttp/HTTPConnector.h" as Callback
class "**HTTPTransactionHandler**\n\nhttp/session/HTTPTransaction.h" as HTTPTransactionHandler
class "**TransactionHandler**\n\n" as TransactionHandler
class "**HttpClient**" as HttpClient

AsyncSocketTransport <-- AsyncSocket

ConnectCallback <- HTTPConnector

Callback <-- HttpClient
HTTPTransactionHandler <-- TransactionHandler

AsyncSocketTransport +-- ConnectCallback
HTTPConnector +-- Callback

'HTTPConnector o-- EventBase
HTTPConnector o-- Callback
HTTPConnector o-- AsyncSocket

TransactionHandler o-- HttpClient

class EventBase {
    loop()
    loopForever()
}

class HTTPConnector {
    connect()
    ----
    {abstract} connectSuccess()
    {abstract} connectErr(AsyncSocketException)
    {abstract} preConnect(NetworkSocket /*fd*/)

    ----
    Callback* httpClient
    folly::AsyncTransport::UniquePtr socket_;
    'wangle::TransportInfo transportInfo_;
}

class AsyncSocket {
    ctor( EventBase )
    connect( ConnectCallback, SocketAddress, int timeout)
}

class TransactionHandler #LightGreen  {
    {abstract} void setTransaction( HTTPTransaction* txn )

    {abstract}  void detachTransaction() // transaction no longer valid

    {abstract} void onHeadersComplete( unique_ptr<HTTPMessage> )
    {abstract} void onBody( unique_ptr<folly::IOBuf> chain )
    {abstract} void onEOM()

    {abstract} void onError( HTTPException )
}

class HttpClient #LightGreen  {
    {abstract} connectSuccess()
    {abstract} connectErr( AsyncSocketException )
    {abstract} preConnect( NetworkSocket )

    {abstract} void setTransaction( HTTPTransaction )
    {abstract}  void detachTransaction()
    {abstract}  void onHeadersComplete( unique_ptr<HTTPMessage> )
    {abstract}  void onBody( unique_ptr<folly::IOBuf> )
}

class ConnectCallback {
    {abstract} connectSuccess() = 0
    {abstract} connectErr( AsyncSocketException ) = 0
    {abstract} preConnect( NetworkSocket /*fd*/ )
}

class Callback {
    {abstract} connectSuccess( HTTPUpstreamSession ) = 0
    {abstract} connectError( folly::AsyncSocketException ) = 0
    {abstract} preConnect( folly::AsyncTransport* )
}

class HTTPTransactionHandler {
    {abstract} void setTransaction( HTTPTransaction* txn )

    {abstract}  void detachTransaction() // transaction no longer valid

    {abstract} void onHeadersComplete( unique_ptr<HTTPMessage> )
    {abstract} void onBody( unique_ptr<folly::IOBuf> chain )
    {abstract} void onEOM()

    {abstract} void onError( HTTPException )
}
----

endif::[]


== useful functions

[source, c++]
----
folly::EventBaseManager::get()->getEventBase(); 
----


== some useful headers

----
folly/SocketAddress.h
proxygen/lib/http/HTTPHeaders.h
proxygen/lib/utils/URL.h
proxygen/lib/http/HTTPMethod.h +
 * HTTPMethod::GET, HTTPMethod::POST
proxygen/lib/utils/WheelTimerInstance.h

_build/generated/proxygen/lib/http/HTTPCommonHeaders.h
----